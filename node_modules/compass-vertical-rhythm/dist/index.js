// Generated by CoffeeScript 1.9.0
var adjustFontSizeTo, convertLength, defaults, establishBaseline, linesForFontSize, objectAssign, parseUnit, rhythm, unit, unitLess;

objectAssign = require('object-assign');

convertLength = require('convert-css-length');

parseUnit = require('parse-unit');

unit = function(length) {
  return parseUnit(length)[1];
};

unitLess = function(length) {
  return parseUnit(length)[0];
};

defaults = {
  baseFontSize: '16px',
  baseLineHeight: 1.5,
  rhythmUnit: 'rem',
  defaultRhythmBorderWidth: '1px',
  defaultRhythmBorderStyle: 'solid',
  roundToNearestHalfLine: true,
  minLinePadding: '2px'
};

linesForFontSize = function(fontSize, options) {
  var convert, fontSizeInPx, lineHeightInPx, lines, minLinePadding;
  convert = convertLength(options.baseFontSize);
  fontSizeInPx = unitLess(convert(fontSize, 'px'));
  lineHeightInPx = unitLess(options.baseLineHeightInPx);
  minLinePadding = unitLess(convert(options.minLinePadding, 'px'));
  if (options.roundToNearestHalfLine) {
    lines = Math.ceil(2 * fontSizeInPx / lineHeightInPx) / 2;
  } else {
    lines = Math.ceil(fontSizeInPx / lineHeightInPx);
  }
  if ((lines * lineHeightInPx - fontSizeInPx) < (minLinePadding * 2)) {
    if (options.roundToNearestHalfLine) {
      lines += 0.5;
    } else {
      lines += 1;
    }
  }
  return lines;
};

rhythm = function(options) {
  var convert;
  convert = convertLength(options.baseFontSize);
  return function(lines, fontSize, offset) {
    var length, rhythmLength;
    if (lines == null) {
      lines = 1;
    }
    if (fontSize == null) {
      fontSize = options.baseFontSize;
    }
    if (offset == null) {
      offset = 0;
    }
    length = ((lines * unitLess(options.baseLineHeightInPx)) - offset) + "px";
    rhythmLength = convert(length, options.rhythmUnit, fontSize);
    if (unit(rhythmLength) === "px") {
      rhythmLength = Math.floor(unitLess(rhythmLength)) + unit(rhythmLength);
    }
    return parseFloat(unitLess(rhythmLength).toFixed(5)) + unit(rhythmLength);
  };
};

establishBaseline = function(options) {
  var convert;
  convert = convertLength(options.baseFontSize);
  return {
    fontSize: (unitLess(options.baseFontSize) / 16) * 100 + "%",
    lineHeight: convert(options.baseLineHeightInPx, 'em')
  };
};

adjustFontSizeTo = function(toSize, lines, fromSize, options) {
  var convert, r;
  if (fromSize == null) {
    fromSize = options.baseFontSize;
  }
  if (unit(toSize) === "%") {
    toSize = unitLess(options.baseFontSize) * (unitLess(toSize) / 100) + "px";
  }
  convert = convertLength(options.baseFontSize);
  fromSize = convert(fromSize, 'px');
  toSize = convert(toSize, 'px', fromSize);
  r = rhythm(options);
  if (lines === "auto") {
    lines = linesForFontSize(toSize, options);
  }
  return {
    fontSize: convert(toSize, options.rhythmUnit, fromSize),
    lineHeight: r(lines, fromSize)
  };
};

module.exports = function(options) {
  var convert, defaultsCopy, fontSizeInPx, lineHeight;
  defaultsCopy = JSON.parse(JSON.stringify(defaults));
  options = objectAssign(defaultsCopy, options);
  convert = convertLength(options.baseFontSize);
  if (unit(options.baseLineHeight)) {
    fontSizeInPx = unitLess(convert(options.baseFontSize, 'px'));
    lineHeight = convert(options.baseLineHeight, 'px');
    options.baseLineHeightInPx = lineHeight;
    options.baseLineHeight = unitLess(lineHeight) / fontSizeInPx;
  } else {
    options.baseLineHeightInPx = (unitLess(options.baseFontSize) * options.baseLineHeight) + "px";
  }
  return {
    rhythm: rhythm(options),
    establishBaseline: function() {
      return establishBaseline(options);
    },
    linesForFontSize: function(fontSize) {
      return linesForFontSize(fontSize, options);
    },
    adjustFontSizeTo: function(toSize, lines, fromSize) {
      if (lines == null) {
        lines = "auto";
      }
      return adjustFontSizeTo(toSize, lines, fromSize, options);
    }
  };
};
